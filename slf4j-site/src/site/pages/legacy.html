<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>Log4j Bridge</title>
  <link rel="stylesheet" type="text/css" media="screen" href="css/site.css" />
  <link rel="stylesheet" type="text/css" media="print" href="css/print.css" />
  
</head>
<body>
  <script type="text/javascript">prefix='';</script>

  <script src="templates/header.js" type="text/javascript"></script>
  <div id="left">
    <script src="templates/left.js" type="text/javascript"></script>
  </div>
  <div id="content">
	

    <h2>Bridging legacy APIs</h2>
    
    <p>Often, some of the components you depend on rely on a logging
    API other than SLF4J. You may also assume that these components
    will not switch to SLF4J in the immediate future. To deal with
    such circumstances, SLF4J ships with several bridging modules
    which redirect calls made to log4j, JCL and java.util.logging APIs
    to behave as if they were made to the SLF4J API instead. The
    figure below illustrates the idea.
    </p>
    
    <p></p>
    <p></p>
    
    
    <p><a href="images/bridging.png">
    <img src="images/bridging.png" alt="click to enlarge" width="800"/>
    </a></p>
    
    <p>
    </p>
    
    <h3><a name="jcl-over-slf4j" href="#jcl-over-slf4j">Gradual migration to
    SLF4J from Jakarta Commons Logging (JCL)</a></h3>
    
    <h4><em>jcl-over-slf4j.jar</em></h4>
    
    <p>To ease migration to SLF4J from JCL, SLF4J distributions
    include the jar file <em>jcl-over-slf4j.jar</em>. This jar file is
    intended as a drop-in replacement for JCL version 1.1.1. It
    implements the public API of JCL but using SLF4J underneath, hence
    the name "JCL over SLF4J."
    </p>
    
    <p>Our JCL over SLF4J implementation will allow you to migrate to
    SLF4J gradually, especially if some of the libraries your software
    depends on continue to use JCL for the foreseeable future. You can
    immediately enjoy the benefits of SLF4J's reliability and preserve
    backward compatibility at the same time. Just replace
    <em>commons-logging.jar</em> with
    <em>jcl-over-slf4j.jar</em>. Subsequently, the selection of the
    underlying logging framework will be done by SLF4J instead of JCL
    <a href="http://articles.qos.ch/classloader.html">but without the
    class loader headaches plaguing JCL</a>. The underlying logging
    framework can be any of the frameworks supported by SLF4J. Often
    times, replacing <em>commons-logging.jar</em> with
    <em>jcl-over-slf4j.jar</em> will immediately and permanently solve
    class loader issues related to commons logging.
    </p>
    
    <h3><em>slf4j-jcl.jar</em></h3>
    
    <p>Some of our users after having switched to SLF4J API realize that
    in some contexts the use of JCL is mandatory and their use of SLF4J
    can be a problem. For this uncommon but important case, SLF4J offers
    a JCL binding, found in the file <em>slf4j-jcl.jar</em>. The JCL
    binding will delegate all logging calls made through SLF4J API to
    JCL. Thus, if for some reason an existing application <em>must</em>
    use JCL, your part of that application can still code against the
    SLF4J API in a manner transparent to the larger application
    environment. Your choice of SLF4J API will be invisible to the rest
    of the application which can continue to use JCL.
    </p>
    
    <h3><em>jcl-over-slf4j.jar</em> should not be confused with
    <em>slf4j-jcl.jar</em></h3>
    
    
    <p>JCL-over-SLF4J, i.e. <em>jcl-over-slf4j.jar</em>, comes in handy
    in situations where JCL needs to be supported for backward
    compatibility reasons. It can be used to fix problems associated
    with JCL, without necessarily adopting the SLF4J API, a decision
    which can be deferred to a later time.
    </p>
    
    <p>On the other hand, <em>slf4j-jcl.jar</em> is useful
    <strong>after</strong> you have already adopted the SLF4J API for
    your component which needs to be embedded in a larger application
    environment where JCL is a formal requirement. Your software
    component can still use SLF4J API without disrupting the larger
    application. Indeed, <em>slf4j-jcl.jar</em> will delegate all
    logging decisions to JCL so that the dependency on SLF4J API by your
    component will be transparent to the larger whole.
    </p>
    
    <p>Please note that <em>jcl-over-slf4j.jar</em> and
    <em>slf4j-jcl.jar</em> cannot be deployed at the same time. The
    former jar file will cause JCL to delegate the choice of the
    logging system to SLF4J and the latter jar file will cause SLF4J
    to delegate the choice of the logging system to JCL, resulting in
    an <a href="codes.html#jclDelegationLoop">infinite loop</a>.
    </p>
    
    
    <h3><a name="log4j-over-slf4j" href="#log4j-over-slf4j">Log4j over
    SLF4J</a></h3>
    
    <p>SLF4J ship with a module called <em>log4j-over-slf4j</em>.  It
    allows log4j users to migrate existing applications to SLF4J without
    changing <em>a single line of code</em> but simply by replacing the
    <em>log4j.jar</em> file with <em>log4j-over-slf4j.jar</em>, as
    described below.
    </p>
    
    <h4>How does it work?</h4>
    
    <p>The log4j-over-slf4j module contains replacements of most widely
    used log4j classes, namely <code>org.apache.log4j.Category</code>,
    <code>org.apache.log4j.Logger</code>,
    <code>org.apache.log4j.Priority</code>,
    <code>org.apache.log4j.Level</code>,
    <code>org.apache.log4j.MDC</code>, and
    <code>org.apache.log4j.BasicConfigurator</code>. These replacement
    classes redirect all work to their corresponding SLF4J classes.
    </p>
    
    <p>To use log4j-over-slf4j in your own application, the first step
    is to locate and then to replace <em>log4j.jar</em> with
    <em>log4j-over-slf4j.jar</em>. Note that you still need an SLF4J
    binding and its dependencies for log4j-over-slf4j to work properly.
    </p>
    
    <p>In most situations, replacing a jar file is all it takes in
    order to migrate from log4j to SLF4J.
    </p>
    
    <p>Note that as a result of this migration, log4j configuration
    files will no longer be picked up. If you need to migrate your
    log4j.properties file to logback, the <a
    href="http://logback.qos.ch/translator/">log4j translator</a> might
    be of help. For configuring logback, please refer to <a
    href="http://logback.qos.ch/manual/index.html">its manual</a>.
    </p>
    
    <h4>When does it not work?</h4>
    
    <p>The <em>log4j-over-slf4j</em> module will not work when the
    application calls log4j components that are not present in the
    bridge.  For example, direct references to log4j appenders,
    filters or PropertyConfigurator are not supported by
    log4j-over-slf4j.  While the number of cases where
    log4j-over-slf4j is insufficient is not completely negligible, in
    the vast majority of cases where log4j is configured through a
    configuration file, be it <em>log4j.properties</em> or
    <em>log4j.xml</em>, log4j-over-slf4j is enough in order to migrate
    your application to SLF4J.
    </p>
    
    <h4>What about the overhead?</h4>
    
    <p>There overhead of using log4j-over-slf4j instead of log4j
    directly is relatively small. Given that log4j-over-slf4j
    immediately delegates all work to SLF4J, the CPU overhead should be
    negligible, in the order of a few <em>nanoseconds</em>. There is a
    memory overhead corresponding to an entry in a hashmap per logger,
    which should be usually acceptable even for very large applications
    consisting of several thousand loggers.  Moreover, if you choose
    logback as your underlying logging system, and given that logback is
    both much faster and more memory-efficient than log4j, the gains
    made by using logback should compensate for the overhead of using
    log4j-over-slf4j instead of log4j directly.
    </p>
    
    <h4>log4j-over-slf4j.jar and slf4j-logj12.jar cannot be present
    simultaneously
    </h4>
    
    <p>The presence of <em>slf4j-logj12.jar</em>, that is the log4j
    binding for SLF4J, will force all SLF4J calls to be delegated to
    log4j. The presence of <em>log4j-over-slf4j.jar</em> will in turn
    delegate all log4j API calls to their SLF4J equivalents. If both
    are present simultaneously, slf4j calls will be delegated to
    log4j, and log4j calls redirected to SLF4j, resulting in an <a
    href="codes.html#log4jDelegationLoop">endless loop</a>.
    </p>
    
    <h3><a name="jul-to-slf4j" href="jul-to-slf4j">JUL to SLF4J</a></h3>
    
    <p>The jul-to-slf4j module includes a jul handler, namely
    SLF4JBridgeHandler, that routes all incoming jul records to the
    SLF4j API. Please see <a
    href="api/org/slf4j/bridge/SLF4JBridgeHandler.html">SLF4JBridgeHandler
    javadocs</a> for usage instructions. 
    </p>

    <p>Contrary to other bridging modules such as jcl-over-slf4j and
    log4j-over-slf4j, which re-implement JCL and respectively log4j,
    the jul-to-slf4j modules does not re-implement the
    java.util.logging package because packages under the java.*
    namespace cannot be replaced. Instead, translates <a
    href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/logging/LogRecord.html?is-external=true">LogRecord</a>
    object into its SLF4J equivalent on each logging event.  Please
    note this traslation process incurs the cost of constructing a
    <code>LogRecord</code> instance regardless of whether the SLF4J
    logger is disabled for the given level or nor. <b>Consequently,
    j.u.l. to SLF4J translation can seriously impact on the cost of
    disabled logging statements (60 fold increase) and a measurable
    impact on enabled log statements (20% overall increase).</b>
    </p>

    <p>If application performance is a concern, then use of
    SLF4JBridgeHandler is appropriate only if few j.u.l. logging
    statements are in play. </p>
   
    
    <h4>jul-to-slf4j.jar and slf4j-jdk14.jar cannot be present
    simultaneously
    </h4>
    
    <p>The presence of slf4j-jdk14.jar, that is the jul binding for
    SLF4J, will force SLF4J calls to be delegated to jul. On the other
    hand, the presence of jul-to-slf4j.jar, plus the installation of
    SLF4JBridgeHandler, by invoking "SLF4JBridgeHandler.install()" will
    route jul records to SLF4J. Thus, if both jar are present
    simultaneously (and SLF4JBridgeHandler is installed), slf4j calls
    will be delegated to jul and jul records will be routed to SLF4J,
    resulting in an endless loop.
    </p> 
    
    <h3><a name="sysout-over-slf4j" href="sysout-over-slf4j">System.out and err over SLF4J</a></h3>
    
    <p>The sysout-over-slf4j module allows a user to redirect all calls
    to System.out and System.err to an SLF4J defined logger with the
    name of the fully qualified class in which the System.out.println
    (or similar) call was made, at configurable levels.
    </p>
    
    <h4>What are the intended use cases?</h4>
    
    <p>The sysout-over-slf4j module is for cases where your legacy codebase,
    or a third party module you use, prints directly to the console and
    you would like to get the benefits of a proper logging framework,
    with automatic capture of information like timestamp and the ability
    to filter which messages you are interested in seeing and control where
    they are sent.
    </p>
    
    <p>The sysout-over-slf4j module is explicitly not intended to encourage
    the use of System.out or System.err for logging purposes.  There is a
    significant performance overhead attached to its use, and as such it
    should be considered a stop-gap for your own code until you can alter
    it to use SLF4J directly, or a work-around for poorly behaving third
    party modules.
    </p>
    
    <h4>What needs to be done to make it work?</h4>
    
    <p>sysout-over-slf4j.jar should be included on the classpath at the
    same level as slf4j-api.jar and your chosen slf4j implementation.
    </p>
    
    <p>A static method call sendSystemOutAndErrToSLF4J() should be made
    on the org.slf4j.sysoutslf4j.context.SysOutOverSLF4J class early in
    the life of the application to start redirecting calls to SLF4J, or
    the included org.slf4j.sysoutslf4j.context.SysOutOverSLF4JServletContextListener
    may be configured in a servlet application.
    </p>
    
    <h4>How does it work?</h4>
    
    <p>The System.out and System.err PrintStreams are replaced with
    new SLF4JPrintStreams. Each time a call to System.out.println (or
    similar) is made, the current thread's stacktrace is examined to
    determine which class made the call.  An SLF4J Logger named after
    that class's fully qualified name is retrieved and the message
    logged at the configured level on that logger (by default info for
    System.out calls and error for System.err calls).
    </p>
    
    <p>Calls to Throwable.printStackTrace() are likewise logged at
    the configured level for each System output. By default there
    will be a message logged for every line of the stack trace; this
    is an unfortunate side effect of not being able reliably to
    retrieve the original exception that is being printed.
    </p>
    
    <p>A servlet container may contain multiple web applications.
    If it has child first class loading and these applications
    package SLF4J in the web-app/lib directory then there will be
    multiple SLF4J instances running in the JVM. However, there
    is only one System.out and one System.err for the whole JVM.
    In order to ensure that the correct SLF4J instance is used
    for the correct web application, inside the new PrintStreams
    SLF4J instances are mapped against the context
    class loader to ensure that the same SLF4J instance used in
    "normal" logging is also used when calling System.out.println.
    </p>
    
    <p>In order to prevent classloader leaks when contexts
    are reloaded the new PrintStreams are created by a special
    classloader so that they do not themselves maintain a reference
    to the context classloader. However, since the PrintStreams do
    maintain a reference to the context's SLF4J instance the user
    must also stop sending System.out/err to SLF4J in a context before
    discarding or reloading it to avoid a classloader leak via the
    stopSendingSystemOutAndErrToSLF4J method on the SysOutOverSLF4J
    class. This happens automatically if using the provided
    SysOutOverSLF4JServletContextListener.
    </p>
    
    <h4>Don't most logging systems print to the console?
    Won't that mean infinite recursion?</h4>
    
    <p>Fortunately, Log4J, JULI & Logback all do so through the
    write methods on PrintStream, which are rarely used for direct
    logging. Consequently these methods on the new PrintStreams proxy
    directly to the old System.out/err PrintStreams, allowing these
    logging frameworks to work as before.
    </p>
    
    <p>Other SLF4J implementations may not fit this useful pattern.
    They can be registered with sysout-over-slf4j via static methods
    on the SysOutOverSLF4J class to permit them to access the console.
    </p>
    
    <h4>What about the overhead?</h4>
    
    <p>The overhead for Log4J, JULI and Logback when printing to the
    console should be minimal, for the reasons outlined above.</p>
    
    <p>The overhead for any SLF4J implementation that needed to be
    registered will be greater; on every attempt by it to print
    to the console its fully qualified classname has to be matched
    against registered package names in order to determine whether
    it should be permitted direct access.
    </p>
    
    <p>Finally, the overhead of actual System.out and System.err calls
    will be much greater, due to the expense of generating
    the thread's stacktrace and examining it to determine the origin
    of the call. As emphasised above, it would be much better if all
    logging were done via SLF4J directly and this module were not
    necessary. 
    </p>

    <script  src="templates/footer.js" type="text/javascript"></script> 
  </div> 
</body> 
</html>
